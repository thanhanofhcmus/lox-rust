# ==========================================
# TEST SUITE: Core Language Features
# ==========================================

# --- 1. Arithmetic & Type Promotion ---
print("--- Running Arithmetic Tests...");

assert(10 + 5 == 15, "Integer addition failed");
assert(10 / 2 == 5, "Exact division should remain an Integer");
assert(5 / 2 == 2.5, "Inexact division must promote to Floating");
assert(10.0 == 10, "Floating and Integer should be equal if values match");
assert(10.5 > 10, "Floating/Integer comparison failed");

print();

# --- 2. Boolean Logic ---
print("--- Running Logic Tests...");

assert(true and true, "Logic 'and' failed");
assert(true or false, "Logic 'or' failed");
assert(not false, "Logic 'not' failed");
assert(if (10 > 5) { true } else { false }, "If expression failed");

print();

# --- 3. Data Structures ---
print("--- Running Data Structure Tests...");

# Testing Arrays
var list = [10, nil, true];
assert(list[0] == 10, "Array indexing failed");
assert(list[2], "Array end indexing failed");

# Testing Maps
var registry = %{
    "name" => "Gemini",
    100 => "Centurion",
    true => "Active"
};

assert(registry["name"] == "Gemini", "Map string key failed");
assert(registry[100] == "Centurion", "Map integer key failed");

print();

# --- 4. Control Flow Expressions ---
print("--- Running Control Flow Tests...");

var score = 85;
var grade = when {
    score >= 90 -> "A",
    score >= 80 -> "B",
    true        -> "F"
};
assert(grade == "B", "When expression failed");

print_raw();

# --- 5. Function & Scope ---
print("--- Running Function Tests...");

var multiplier = 2;
var scale = fn(n) n * multiplier;

assert(scale(5) == 10, "Function call or closure scope failed");

var factorial = fn(n) {
    if n <= 1 { return 1; }
    return n * factorial(n - 1);
};
assert(factorial(5) == 120, "Recursive function call failed");


# --- 6. The "Usize" conversion (Index Testing) ---
# This tests the 'prepare_usize' logic we wrote in Rust
var arr = ["zero", "one", "two"];
var idx = 2.0;
assert(arr[idx] == "two", "Float-as-integer index conversion failed");

print();

# --- 6. Chaining
print("--- Running Chaining Tests...");
var arr_fn_a = fn() [[1, 2, 3],[4, 5, 6]];
var fn_arr = [[], [], [0, 0, [0, arr_fn_a]]];
var arr_fn_b = fn() [[], fn_arr];
var map_arr = %{ "b" => arr_fn_b };
var arr_fn_index = fn() 2;
assert(arr_fn_b()[1][2][arr_fn_index()][1]()[1][2] == 6, "Chaining function call and array failed");
assert(map_arr["b"]()[1][arr_fn_index()][2][1]()[1][0] == 4, "Chaining function call and array and map failed");

print();

# --- 7. Equality & Comparison Deep Dive ---
print("--- Running Equality & Comparison Tests...");

# Standard Equality
assert(10 == 10, "Integer equality failed");
assert("test" == "test", "String equality failed");
assert(nil == nil, "Nil equality failed");

# Cross-type Numeric Equality (Coercion)
# Tests your: (Integer(l), Floating(r)) => *l as f64 == *r
assert(5 == 5.0, "Integer 5 should equal Float 5.0");
assert(0 == 0.0, "Zeroes of different types should be equal");
assert(not (5 == 5.1), "Integer 5 should NOT equal Float 5.1");

# Type Mismatches (Should return false, NOT error)
assert(not (10 == "10"), "Integer 10 should not equal String '10'");
assert(not (true == 1), "Boolean true should not equal Integer 1");

# Recursive Collection Equality
assert([1, 2, [3, 4]] == [1, 2, [3, 4]], "Recursive array equality failed");
assert([1, 5.0] == [1.0, 5], "Cross-type numeric array equality failed");

var map_a = %{ "x" => 10, "y" => [1, 2] };
var map_b = %{ "x" => 10.0, "y" => [1.0, 2.0] };
assert(map_a == map_b, "Recursive map equality with coercion failed");

# Ordering with Mixed Types
assert(10.5 > 10, "Float vs Integer comparison failed");
assert(5.0 >= 5, "Float vs Integer inclusive comparison failed");
assert("apple" < "banana", "String lexicographical comparison failed");

# Function Identity (Pointer Equality)
var f_identity = fn(a) a;
var g_identity = f_identity;
var h_identity = fn(a) a; # Same body, different instance

var l_identity = print;
var m_identity = print;
var n_identity = assert;

# Equal tests are falling since we have not create function pointer yet
assert(f_identity == g_identity, "Pointer equality for same function instance failed");
assert(not (f_identity == h_identity), "Different function instances should not be equal");

assert(l_identity == m_identity, "Pointer equality for the same built-in function failed");
assert(l_identity == print, "Pointer equality for the same built-in function failed");
assert(not (l_identity == n_identity), "Pointer equality for the same built-in function failed");

print();

# --- 8. Expression Blocks ---
print("--- Expression Blocks Tests...");

# 1. Simple Function Implicit Return
var add_five = fn(n) {
    var bonus = 5;
    n + bonus    # No semicolon/return keyword needed
};
assert(add_five(10) == 15, "Implicit return in simple function failed");

# 2. If-Else as an Expression
var condition = true;
var result = if condition {
    "it was true"
} else {
    "it was false"
};
assert(result == "it was true", "If-Else as expression failed");

# 3. Block with multiple side-effects
var complex_fn = fn() {
    var a = 10;
    var b = 20;
    var c = a + b;
    print("Side effect: calculating c...");
    c # This should be the return value
};
assert(complex_fn() == 30, "Implicit return with side effects failed");

# 4. Nested Implicit Returns
# The value from the inner 'if' block becomes the value of the function block
var nested_implicit = fn(x) {
    if x > 0 {
        "positive"
    } else {
        "negative"
    }
};
assert(nested_implicit(10) == "positive", "Nested implicit return failed");

# 5. Mixing Implicit and Explicit Return
# This tests if an explicit 'return' still works correctly
var early_return = fn(check) {
    if check {
        return "early";
    }
    "late"
};
assert(early_return(true) == "early", "Explicit return inside implicit block failed (early)");
assert(early_return(false) == "late", "Explicit return inside implicit block failed (late)");

print();
